<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>BRIGADA • PLAYER</title>

  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jsmediatags/3.9.5/jsmediatags.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">

  <style>
    :root{
      --bgTop:#05060a;

      /* Эти цвета будут подхватываться из обложки */
      --c1:#1b66ff;
      --c2:#74b7ff;
      --c3:#bfe0ff;

      --text:rgba(255,255,255,.92);
      --muted:rgba(255,255,255,.55);

      --safeTop: env(safe-area-inset-top);
      --safeBottom: env(safe-area-inset-bottom);

      /* где граница (0..1). 0.66 = 2/3 сверху */
      --split: 0.66;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      background: var(--bgTop);
      color: var(--text);
      overflow:hidden;
      font-family:'Press Start 2P', cursive;
      text-transform: uppercase;
      -webkit-font-smoothing: antialiased;
    }

    /* ЕДИНЫЙ ФОН НА ВЕСЬ ЭКРАН */
    .scene{
      position:fixed; inset:0;
      background:
        linear-gradient(180deg,
          rgba(0,0,0,0.92) 0%,
          rgba(0,0,0,0.92) calc(var(--split) * 100% - 8%),
          rgba(0,0,0,0.20) calc(var(--split) * 100% + 5%),
          rgba(0,0,0,0.12) 100%),
        radial-gradient(1200px 900px at 50% 100%,
          color-mix(in srgb, var(--c1) 80%, transparent),
          transparent 60%),
        radial-gradient(900px 700px at 25% 100%,
          color-mix(in srgb, var(--c2) 70%, transparent),
          transparent 55%),
        radial-gradient(900px 700px at 80% 100%,
          color-mix(in srgb, var(--c3) 65%, transparent),
          transparent 55%);
      filter: saturate(1.10);
    }

    /* размытие обложки в нижней зоне (красиво как у тебя на фото) */
    .coverBlur{
      position:fixed; inset:0;
      background-size: cover;
      background-position:center;
      filter: blur(42px) saturate(1.25) brightness(.75);
      transform: scale(1.18);
      opacity:0;
      transition: opacity .35s ease;
      mask-image: linear-gradient(180deg,
        rgba(0,0,0,0) 0%,
        rgba(0,0,0,0) calc(var(--split) * 100% - 6%),
        rgba(0,0,0,1) calc(var(--split) * 100% + 4%),
        rgba(0,0,0,1) 100%);
    }
    .coverBlur.on{ opacity:0.95; }

    /* Canvas-слой “дымной границы” */
    canvas#smoke{
      position:fixed; inset:0;
      width:100%; height:100%;
      pointer-events:none;
      z-index:5;
    }

    /* UI поверх */
    .ui{
      position:relative;
      height:100%;
      z-index:10;
      display:flex;
      flex-direction:column;
      padding: calc(var(--safeTop) + 14px) 14px calc(var(--safeBottom) + 14px);
      gap:12px;
    }

    /* Верхняя зона — просто контейнер, без “карточки” */
    .topZone{
      flex: 2 1 0;
      min-height:0;
      display:flex;
      flex-direction:column;
      justify-content:flex-start;
      gap:12px;
    }

    /* Нижняя зона — для кнопок/прогресса */
    .bottomZone{
      flex: 1 1 0;
      min-height:0;
      display:flex;
      flex-direction:column;
      justify-content:flex-end;
      gap:10px;
      padding-bottom: 2px;
    }

    /* Текст сверху */
    .brand{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
    }
    .brandLeft{ display:flex; flex-direction:column; gap:6px; min-width:0; }
    .brandTitle{
      font-size:11px;
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }
    .brandSub{
      font-size:7px;
      color: var(--muted);
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }

    .trackBlock{ margin-top:auto; padding-top:12px; }
    .tTitle{
      margin:0;
      font-size:14px;
      line-height:1.25;
      color: rgba(255,255,255,.95);
      text-shadow: 0 14px 50px rgba(0,0,0,.55);
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }
    .tArtist{
      margin-top:10px;
      font-size:9px;
      color: rgba(255,255,255,.65);
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }

    /* Нижняя панель под “мутным стеклом” */
    .controls{
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.12);
      backdrop-filter: blur(18px);
      -webkit-backdrop-filter: blur(18px);
      border-radius: 22px;
      padding: 12px;
      box-shadow: 0 26px 80px rgba(0,0,0,.55);
    }

    .row{ display:flex; gap:10px; align-items:center; }
    .btn{
      flex:1;
      border:none;
      border-radius: 18px;
      padding: 12px 10px;
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      font-family:'Press Start 2P', cursive;
      font-size:10px;
      color: rgba(255,255,255,.92);
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.12);
    }
    .btnPlay{
      flex:2;
      background: linear-gradient(90deg,
        color-mix(in srgb, var(--c2) 35%, rgba(255,255,255,.06)),
        color-mix(in srgb, var(--c1) 25%, rgba(255,255,255,.06))
      );
      border-color: rgba(255,255,255,.18);
    }

    .bar{
      height:14px;
      border-radius:999px;
      background: rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.10);
      overflow:hidden;
      cursor:pointer;
    }
    .fill{
      height:100%;
      width:0%;
      background: linear-gradient(90deg, var(--c1), var(--c2), var(--c3));
      box-shadow: 0 0 24px color-mix(in srgb, var(--c2) 35%, transparent);
    }

    .timeRow{
      display:flex; justify-content:space-between;
      font-size:7px; color: rgba(255,255,255,.55);
      margin-top:8px;
    }

    .toggleRow{ display:flex; gap:10px; margin-top:10px; }
    .toggle{
      flex:1;
      border-radius: 18px;
      padding: 10px 10px;
      font-family:'Press Start 2P', cursive;
      font-size:8px;
      color: rgba(255,255,255,.60);
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.12);
      cursor:pointer;
    }
    .toggle.on{
      color: rgba(0,0,0,.9);
      background: linear-gradient(90deg,
        color-mix(in srgb, var(--c2) 80%, white),
        color-mix(in srgb, var(--c1) 70%, white)
      );
      border-color: rgba(255,255,255,.20);
    }

    /* bottom sheet */
    .sheet{
      position:fixed;
      left:0; right:0;
      bottom: calc(-72vh + var(--safeBottom));
      height: 72vh;
      border-radius: 26px 26px 0 0;
      background: rgba(12,12,18,.76);
      border-top: 1px solid rgba(255,255,255,.14);
      backdrop-filter: blur(22px);
      -webkit-backdrop-filter: blur(22px);
      box-shadow: 0 -30px 90px rgba(0,0,0,.55);
      transform: translateY(0);
      transition: transform .22s ease;
      z-index: 30;
      display:flex;
      flex-direction:column;
      overflow:hidden;
      touch-action: none;
    }
    .sheet.open{ transform: translateY(-72vh); }
    .sheetHeader{
      padding: 10px 14px 12px;
      border-bottom: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.04);
    }
    .handle{
      width:48px; height:6px;
      border-radius:999px;
      background: rgba(255,255,255,.22);
      margin: 8px auto 10px;
    }
    .sheetTopRow{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
    }
    .sheetTitle{ font-size:9px; color: rgba(255,255,255,.86); }
    .sheetClose{
      font-size:8px;
      padding:10px 12px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.05);
      color: rgba(255,255,255,.92);
      cursor:pointer;
    }
    .sheetBody{
      padding: 12px 14px 14px;
      display:flex;
      flex-direction:column;
      gap:12px;
      min-height:0;
      overflow:hidden;
    }
    .search{
      width:100%;
      padding: 12px 12px;
      border-radius: 18px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.05);
      color: rgba(255,255,255,.92);
      font-family:'Press Start 2P', cursive;
      font-size:8px;
      outline:none;
    }
    .search::placeholder{ color: rgba(255,255,255,.35); }
    .list{
      min-height:0;
      overflow:auto;
      padding-right: 6px;
      margin-right: -6px;
    }
    .item{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      padding: 12px 12px;
      border-radius: 18px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.04);
      cursor:pointer;
      margin-bottom:10px;
    }
    .item.active{
      border-color: rgba(255,255,255,.20);
      background: rgba(255,255,255,.07);
    }
    .itLeft{ min-width:0; }
    .itTitle{
      margin:0;
      font-size:8px;
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
      color: rgba(255,255,255,.92);
    }
    .itArtist{
      margin-top:6px;
      font-size:7px;
      color: rgba(255,255,255,.55);
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }
    .badge{
      font-size:7px;
      color: rgba(255,255,255,.78);
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.05);
      flex:0 0 auto;
    }
  </style>
</head>

<body>
  <div class="scene"></div>
  <div class="coverBlur" id="coverBlur"></div>
  <canvas id="smoke"></canvas>

  <div class="ui">
    <div class="topZone" id="topZone">
      <div class="brand">
        <div class="brandLeft">
          <div class="brandTitle">BRIGADA PLAYER</div>
          <div class="brandSub" id="status">CONNECTING...</div>
        </div>
        <div class="brandSub">SWIPE UP</div>
      </div>

      <div class="trackBlock">
        <h1 class="tTitle" id="title">TERMINAL_READY</h1>
        <div class="tArtist" id="artist">SELECT_TRACK</div>
      </div>
    </div>

    <div class="bottomZone">
      <div class="controls">
        <div class="bar" id="bar"><div class="fill" id="fill"></div></div>
        <div class="timeRow"><div id="tCur">0:00</div><div id="tDur">0:00</div></div>

        <div class="row" style="margin-top:10px;">
          <button class="btn" id="prev">&lt;</button>
          <button class="btn btnPlay" id="play">START</button>
          <button class="btn" id="next">&gt;</button>
        </div>

        <div class="toggleRow">
          <button class="toggle" id="shuffle">SHUFFLE: OFF</button>
          <button class="toggle" id="repeat">REPEAT: OFF</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Bottom sheet -->
  <div class="sheet" id="sheet">
    <div class="sheetHeader" id="sheetHeader">
      <div class="handle"></div>
      <div class="sheetTopRow">
        <div class="sheetTitle">LIBRARY</div>
        <button class="sheetClose" id="sheetClose">CLOSE</button>
      </div>
    </div>
    <div class="sheetBody">
      <input class="search" id="search" placeholder="SEARCH_TRACK..." />
      <div class="list" id="playlist"></div>
    </div>
  </div>

  <script>
    // =========================
    // КОНФИГУРАЦИЯ (ФРОНТ)
    // =========================
    const SUPABASE_URL = "https://lrggqgwzalqstwjbgbbn.supabase.co";
    const SUPABASE_KEY = "sb_publishable_gNPjEKC-lYCueII_lnL-HA_gCKV_BFE";
    // =========================

    const tg = window.Telegram?.WebApp;
    try { tg?.expand(); tg?.ready(); } catch(e){}

    const audio = new Audio();
    audio.crossOrigin = "anonymous";

    let tracks = [];
    let filteredTracks = [];
    let currentTrackIndex = 0;
    let isShuffle = false;
    let isRepeat = false;
    let isPlaying = false;
    let lastPlaysTrackId = null;

    const els = {
      status: document.getElementById("status"),
      title: document.getElementById("title"),
      artist: document.getElementById("artist"),
      coverBlur: document.getElementById("coverBlur"),

      bar: document.getElementById("bar"),
      fill: document.getElementById("fill"),
      tCur: document.getElementById("tCur"),
      tDur: document.getElementById("tDur"),

      prev: document.getElementById("prev"),
      play: document.getElementById("play"),
      next: document.getElementById("next"),
      shuffle: document.getElementById("shuffle"),
      repeat: document.getElementById("repeat"),

      sheet: document.getElementById("sheet"),
      sheetHeader: document.getElementById("sheetHeader"),
      sheetClose: document.getElementById("sheetClose"),
      search: document.getElementById("search"),
      playlist: document.getElementById("playlist"),

      smoke: document.getElementById("smoke"),
      topZone: document.getElementById("topZone"),
    };

    function haptic(type="light"){
      try { tg?.HapticFeedback?.impactOccurred(type); } catch(e){}
    }
    function formatTime(sec){
      if (!isFinite(sec)) return "0:00";
      sec = Math.max(0, Math.floor(sec));
      const m = Math.floor(sec / 60);
      const s = sec % 60;
      return `${m}:${String(s).padStart(2,"0")}`;
    }

    // ======= Цвета из обложки (быстро) =======
    async function extractColorsFromUrl(url){
      try{
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.src = url;
        await img.decode();

        const c = document.createElement("canvas");
        const ctx = c.getContext("2d", { willReadFrequently: true });
        const w = 32, h = 32;
        c.width = w; c.height = h;
        ctx.drawImage(img, 0, 0, w, h);

        const data = ctx.getImageData(0,0,w,h).data;
        const samples = [];
        for (let i=0; i<data.length; i+=4*6){
          const r=data[i], g=data[i+1], b=data[i+2], a=data[i+3];
          if (a < 200) continue;
          if (r+g+b < 70) continue;
          samples.push([r,g,b]);
        }
        if (samples.length < 6) return;

        const pick = (base=null) => {
          let best=null, bestD=-1;
          for (const s of samples){
            const d = base
              ? (Math.abs(s[0]-base[0])+Math.abs(s[1]-base[1])+Math.abs(s[2]-base[2]))
              : (s[0]+s[1]+s[2]);
            if (d > bestD){ bestD=d; best=s; }
          }
          return best;
        };
        const c1 = pick(null);
        const c2 = pick(c1);
        const c3 = pick(c2);

        const to = (x)=>`rgb(${x[0]},${x[1]},${x[2]})`;
        document.documentElement.style.setProperty("--c1", to(c1));
        document.documentElement.style.setProperty("--c2", to(c2));
        document.documentElement.style.setProperty("--c3", to(c3));
      } catch(e){}
    }

    function setCoverBlur(url){
      if (!url) { els.coverBlur.classList.remove("on"); return; }
      els.coverBlur.style.backgroundImage = `url('${url}')`;
      els.coverBlur.classList.add("on");
      extractColorsFromUrl(url);
    }

    function tryReadCoverFromMp3(audioUrl){
      try{
        new window.jsmediatags.Reader(audioUrl).read({
          onSuccess: function(tag){
            const pic = tag?.tags?.picture;
            if (!pic) return;
            let base64 = "";
            for (let i=0;i<pic.data.length;i++) base64 += String.fromCharCode(pic.data[i]);
            const dataUrl = `data:${pic.format};base64,${window.btoa(base64)}`;
            setCoverBlur(dataUrl);
          },
          onError: function(){ }
        });
      } catch(e){}
    }

    // ======= Supabase =======
    async function fetchTracks(){
      els.status.textContent = "LOADING...";
      try{
        const response = await fetch(`${SUPABASE_URL}/rest/v1/tracks?select=*&order=id.asc`, {
          headers: { "apikey": SUPABASE_KEY, "Authorization": `Bearer ${SUPABASE_KEY}` }
        });
        if (!response.ok) throw new Error("REST_" + response.status);

        tracks = await response.json();
        filteredTracks = tracks;
        els.status.textContent = tracks.length ? "READY" : "EMPTY_LIBRARY";

        renderPlaylist();
        if (tracks.length) loadTrack(0, { autoplay:false });
        else {
          els.title.textContent = "NO_TRACKS";
          els.artist.textContent = "UPLOAD_MP3";
        }
      } catch(e){
        els.status.textContent = "CONN_ERROR";
        els.title.textContent = "CONN_ERROR";
        els.artist.textContent = "CHECK_KEY_OR_RLS";
      }
    }

    function renderPlaylist(){
      els.playlist.innerHTML = "";
      filteredTracks.forEach((track) => {
        const realIndex = tracks.findIndex(t => t.id === track.id);
        if (realIndex < 0) return;

        const item = document.createElement("div");
        item.className = "item";
        item.dataset.index = String(realIndex);

        const left = document.createElement("div");
        left.className = "itLeft";

        const t = document.createElement("p");
        t.className = "itTitle";
        t.textContent = `[${String(realIndex+1).padStart(2,"0")}] ${track.title || "UNTITLED"}`;

        const a = document.createElement("div");
        a.className = "itArtist";
        a.textContent = track.artist || "UNKNOWN_ARTIST";

        left.appendChild(t);
        left.appendChild(a);

        const badge = document.createElement("div");
        badge.className = "badge";
        badge.textContent = `PLAYS:${track.plays || 0}`;

        item.appendChild(left);
        item.appendChild(badge);

        item.onclick = () => {
          currentTrackIndex = realIndex;
          loadTrack(realIndex, { autoplay:true });
          closeSheet();
          haptic("medium");
        };

        els.playlist.appendChild(item);
      });
      updateActiveItem();
    }

    function updateActiveItem(){
      els.playlist.querySelectorAll(".item").forEach((it) => {
        it.classList.toggle("active", Number(it.dataset.index) === currentTrackIndex);
      });
    }

    function setPlayBtn(){ els.play.textContent = audio.paused ? "START" : "STOP"; }

    function loadTrack(index, { autoplay=false } = {}){
      const track = tracks[index];
      if (!track) return;

      els.title.textContent = track.title || "UNTITLED";
      els.artist.textContent = track.artist || "UNKNOWN_ARTIST";

      audio.src = track.audio_url;
      audio.loop = isRepeat;
      lastPlaysTrackId = null;

      // обложка -> цвета
      els.coverBlur.classList.remove("on");
      if (track.image_url && track.image_url !== "NULL" && String(track.image_url).trim() !== ""){
        setCoverBlur(track.image_url);
      } else {
        tryReadCoverFromMp3(track.audio_url);
      }

      updateActiveItem();
      setPlayBtn();
      if (autoplay) playAudio();
    }

    async function updatePlayCount(track){
      const newCount = (track.plays || 0) + 1;
      track.plays = newCount;
      const badge = els.playlist.querySelector(`.item[data-index="${currentTrackIndex}"] .badge`);
      if (badge) badge.textContent = `PLAYS:${newCount}`;

      try{
        await fetch(`${SUPABASE_URL}/rest/v1/tracks?id=eq.${track.id}`, {
          method: "PATCH",
          headers: {
            "apikey": SUPABASE_KEY,
            "Authorization": `Bearer ${SUPABASE_KEY}`,
            "Content-Type": "application/json"
          },
          body: JSON.stringify({ plays: newCount })
        });
      } catch(e){}
    }

    async function playAudio(){
      const track = tracks[currentTrackIndex];
      if (!track) return;

      try{
        await audio.play();
        isPlaying = true;
        setPlayBtn();
        if (lastPlaysTrackId !== track.id){
          lastPlaysTrackId = track.id;
          updatePlayCount(track);
        }
        startSmoke();
      } catch(e){
        isPlaying = false;
        setPlayBtn();
      }
    }
    function stopAudio(){
      audio.pause();
      isPlaying = false;
      setPlayBtn();
      stopSmoke();
    }

    function nextTrack(){
      if (!tracks.length) return;
      currentTrackIndex = isShuffle
        ? Math.floor(Math.random() * tracks.length)
        : (currentTrackIndex + 1) % tracks.length;
      loadTrack(currentTrackIndex, { autoplay: isPlaying });
      if (isPlaying) playAudio();
    }
    function prevTrack(){
      if (!tracks.length) return;
      currentTrackIndex = (currentTrackIndex - 1 + tracks.length) % tracks.length;
      loadTrack(currentTrackIndex, { autoplay: isPlaying });
      if (isPlaying) playAudio();
    }

    // ======= Sheet свайпы =======
    let sheetOpen = false;
    function openSheet(){ sheetOpen = true; els.sheet.classList.add("open"); haptic("light"); }
    function closeSheet(){ sheetOpen = false; els.sheet.classList.remove("open"); haptic("light"); }
    els.sheetClose.onclick = closeSheet;

    let startY=0, dragging=false;
    function onStart(y){ dragging=true; startY=y; }
    function onMove(y){
      if (!dragging) return;
      const dy = y - startY;
      if (!sheetOpen && dy < -35){ openSheet(); dragging=false; }
      if (sheetOpen && dy > 45){ closeSheet(); dragging=false; }
    }
    function onEnd(){ dragging=false; }
    els.topZone.addEventListener("touchstart",(e)=>onStart(e.touches[0].clientY),{passive:true});
    els.topZone.addEventListener("touchmove",(e)=>onMove(e.touches[0].clientY),{passive:true});
    els.topZone.addEventListener("touchend",onEnd);
    els.sheetHeader.addEventListener("touchstart",(e)=>onStart(e.touches[0].clientY),{passive:true});
    els.sheetHeader.addEventListener("touchmove",(e)=>onMove(e.touches[0].clientY),{passive:true});
    els.sheetHeader.addEventListener("touchend",onEnd);

    els.search.oninput = (e) => {
      const val = (e.target.value || "").toLowerCase().trim();
      filteredTracks = !val ? tracks : tracks.filter(t =>
        String(t.title || "").toLowerCase().includes(val) ||
        String(t.artist || "").toLowerCase().includes(val)
      );
      renderPlaylist();
    };

    // ======= Controls =======
    els.play.onclick = () => { if (audio.paused) playAudio(); else stopAudio(); haptic("medium"); };
    els.next.onclick = () => { nextTrack(); haptic("light"); };
    els.prev.onclick = () => { prevTrack(); haptic("light"); };

    els.shuffle.onclick = () => {
      isShuffle = !isShuffle;
      els.shuffle.textContent = isShuffle ? "SHUFFLE: ON" : "SHUFFLE: OFF";
      els.shuffle.classList.toggle("on", isShuffle);
      haptic("light");
    };
    els.repeat.onclick = () => {
      isRepeat = !isRepeat;
      audio.loop = isRepeat;
      els.repeat.textContent = isRepeat ? "REPEAT: ON" : "REPEAT: OFF";
      els.repeat.classList.toggle("on", isRepeat);
      haptic("light");
    };

    // progress
    audio.ontimeupdate = () => {
      if (!audio.duration) return;
      const pct = (audio.currentTime / audio.duration) * 100;
      els.fill.style.width = pct + "%";
      els.tCur.textContent = formatTime(audio.currentTime);
      els.tDur.textContent = formatTime(audio.duration);
    };
    audio.onended = () => { if (!isRepeat) nextTrack(); };
    els.bar.onclick = (e) => {
      if (!audio.duration) return;
      const r = els.bar.getBoundingClientRect();
      const x = Math.min(Math.max(0, e.clientX - r.left), r.width);
      audio.currentTime = (x / r.width) * audio.duration;
      haptic("light");
    };

    // =========================================
    // ДЫМНАЯ ГРАНИЦА (как на твоём примере)
    // =========================================
    let audioCtx=null, analyser=null, srcNode=null;
    let raf=null;
    const ctx = els.smoke.getContext("2d");

    function ensureGraph(){
      if (audioCtx) return;
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      analyser = audioCtx.createAnalyser();
      analyser.fftSize = 1024;
      analyser.smoothingTimeConstant = 0.88;
      srcNode = audioCtx.createMediaElementSource(audio);
      srcNode.connect(analyser);
      analyser.connect(audioCtx.destination);
    }

    function resizeSmoke(){
      const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      const w = Math.floor(innerWidth * dpr);
      const h = Math.floor(innerHeight * dpr);
      els.smoke.width = w;
      els.smoke.height = h;
      ctx.setTransform(dpr,0,0,dpr,0,0);
    }
    addEventListener("resize", resizeSmoke);
    resizeSmoke();

    // простая noise-функция (без библиотек)
    function n2(x,y){
      const s = Math.sin(x*127.1 + y*311.7) * 43758.5453123;
      return s - Math.floor(s);
    }
    function smoothNoise(x,y){
      const x0 = Math.floor(x), y0 = Math.floor(y);
      const xf = x - x0, yf = y - y0;
      const a = n2(x0,y0), b = n2(x0+1,y0), c = n2(x0,y0+1), d = n2(x0+1,y0+1);
      const u = xf*xf*(3-2*xf);
      const v = yf*yf*(3-2*yf);
      const ab = a + (b-a)*u;
      const cd = c + (d-c)*u;
      return ab + (cd-ab)*v;
    }

    function startSmoke(){
      try{
        ensureGraph();
        if (audioCtx.state === "suspended") audioCtx.resume();
      } catch(e){ return; }

      if (raf) return;

      const freq = new Uint8Array(analyser.frequencyBinCount);
      let t = 0;

      const draw = () => {
        raf = requestAnimationFrame(draw);
        t += 0.016;

        const W = innerWidth;
        const H = innerHeight;

        analyser.getByteFrequencyData(freq);

        // энергия баса (0..1)
        let sum = 0;
        for (let i=0; i<70; i++) sum += freq[i];
        const energy = Math.min(1, sum / (70*255));

        ctx.clearRect(0,0,W,H);

        // линия раздела по split
        const split = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--split")) || 0.66;
        const yBase = H * split;

        // толщина дымной зоны
        const band = 140 + energy*140;

        // рисуем дым: много “ленточных” слоёв
        for (let layer=0; layer<3; layer++){
          const a = 0.10 + layer*0.06 + energy*0.10;
          const speed = 0.55 + layer*0.35;
          const amp = 22 + layer*10 + energy*30;

          ctx.beginPath();
          for (let x=0; x<=W; x+=8){
            const nx = x*0.006;
            const ny = t*speed;
            const s = smoothNoise(nx + layer*10, ny + layer*20);
            const w = Math.sin(x*0.012 + t*speed*1.3 + layer) * 0.45;
            const y = yBase + (s-0.5)*amp + w*amp;
            if (x===0) ctx.moveTo(x,y);
            else ctx.lineTo(x,y);
          }

          // закрываем вниз (в нижнюю зону)
          ctx.lineTo(W, yBase + band);
          ctx.lineTo(0, yBase + band);
          ctx.closePath();

          // “дымное стекло” — светлое, но мягкое
          ctx.fillStyle = `rgba(220,235,255,${a})`;
          ctx.fill();
        }

        // мягкие блики по самой границе
        ctx.globalCompositeOperation = "lighter";
        ctx.beginPath();
        for (let x=0; x<=W; x+=6){
          const s = smoothNoise(x*0.01, t*0.9);
          const y = yBase + (s-0.5)*(16 + energy*22);
          if (x===0) ctx.moveTo(x,y);
          else ctx.lineTo(x,y);
        }
        ctx.strokeStyle = `rgba(255,255,255,${0.12 + energy*0.18})`;
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.globalCompositeOperation = "source-over";

        // IMPORTANT: растворение вверх (как на твоём фото)
        const gradUp = ctx.createLinearGradient(0, yBase - band, 0, yBase + band*0.2);
        gradUp.addColorStop(0, "rgba(0,0,0,0.95)");
        gradUp.addColorStop(0.35, "rgba(0,0,0,0.55)");
        gradUp.addColorStop(1, "rgba(0,0,0,0)");
        ctx.fillStyle = gradUp;
        ctx.fillRect(0, yBase - band, W, band*1.2);

        // и чуть “молока” вниз (как свет внизу на примере)
        const gradDown = ctx.createLinearGradient(0, yBase, 0, yBase + band*0.95);
        gradDown.addColorStop(0, `rgba(255,255,255,${0.10 + energy*0.12})`);
        gradDown.addColorStop(1, "rgba(255,255,255,0)");
        ctx.fillStyle = gradDown;
        ctx.fillRect(0, yBase, W, band);
      };

      draw();
    }

    function stopSmoke(){
      if (raf){ cancelAnimationFrame(raf); raf=null; }
    }

    audio.addEventListener("pause", stopSmoke);
    audio.addEventListener("ended", stopSmoke);

    // ======= init =======
    fetchTracks();
  </script>
</body>
</html>
